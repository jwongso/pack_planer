<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WASM System Profiler Test</title>
</head>
<body>
  <h1>WASM System Profiler Test</h1>

  <div id="loading">Loading WASM module...</div>

  <div id="controls" style="display: none;">
    <h2>System Profiling Controls</h2>
    <button onclick="runQuickProfile()">Run Quick Profile</button>
    <button onclick="runStressTest()">Run Stress Test (5s)</button>
    <button onclick="runNetworkTest()">Test Network Performance</button>
    <button onclick="getBatteryStatus()">Get Battery Status</button>
    <button onclick="runFullProfile()">Run Full Profile</button>
  </div>

  <div id="results">
    <h2>Profiling Results</h2>
    <div id="output"></div>
  </div>

  <!-- âœ… Load WASM wrapper with <script type="module"> -->
  <script type="module">
    import Module from './pack_planner_wasm.js';

    let profiler = null;
    let networkLatency = 0;
    let networkBandwidth = 0;
    let batteryLevel = 1.0;
    let isCharging = true;

    function log(message) {
        const output = document.getElementById('output');
        const timestamp = new Date().toLocaleTimeString();
        output.innerHTML += `<p><strong>[${timestamp}]</strong> ${message}</p>`;
        output.scrollTop = output.scrollHeight;
    }

    function calculateRecommendation(results) {
        const weights = {
            cpu: 0.3,
            memory: 0.25,
            networkLatency: 0.2,
            networkBandwidth: 0.15,
            battery: 0.1
        };

        const cpuNorm = Math.min(results.cpuScore / 10.0, 1.0);
        const memoryNorm = Math.min(results.memoryBandwidthMbps / 10000.0, 1.0);
        const latencyNorm = Math.max(0, 1.0 - (results.networkLatencyMs / 1000.0));
        const bandwidthNorm = Math.min(results.networkBandwidthMbps / 100.0, 1.0);
        const batteryNorm = results.batteryLevel;

        const overallScore =
            cpuNorm * weights.cpu +
            memoryNorm * weights.memory +
            latencyNorm * weights.networkLatency +
            bandwidthNorm * weights.networkBandwidth +
            batteryNorm * weights.battery;

        let decision;
        if (overallScore > 0.7) {
            decision = 'CLIENT_PREFERRED';
        } else if (overallScore > 0.4) {
            decision = 'HYBRID';
        } else {
            decision = 'SERVER_PREFERRED';
        }

        return {
            decision: decision,
            confidence: overallScore
        };
    }

    async function initializeBatteryAPI() {
        if ('getBattery' in navigator) {
            try {
                const battery = await navigator.getBattery();
                batteryLevel = battery.level;
                isCharging = battery.charging;

                battery.addEventListener('levelchange', () => {
                    batteryLevel = battery.level;
                });

                battery.addEventListener('chargingchange', () => {
                    isCharging = battery.charging;
                });

                log(`Battery API initialized: ${(batteryLevel * 100).toFixed(1)}%, ${isCharging ? 'charging' : 'not charging'}`);
            } catch (error) {
                log(`Battery API not available: ${error.message}`);
            }
        } else {
            log('Battery API not supported in this browser');
        }
    }

    async function runNetworkTest() {
        log('Testing network performance...');
        try {
            const endpoints = [
                'https://httpbin.org/delay/0',
                'https://jsonplaceholder.typicode.com/posts/1',
                'https://api.github.com'
            ];

            let totalLatency = 0;
            let successfulTests = 0;

            for (const endpoint of endpoints) {
                try {
                    const start = performance.now();
                    const response = await fetch(endpoint, { method: 'HEAD' });
                    const end = performance.now();

                    if (response.ok) {
                        totalLatency += (end - start);
                        successfulTests++;
                    }
                } catch (e) {
                    log(`Failed to test ${endpoint}: ${e.message}`);
                }
            }

            if (successfulTests > 0) {
                networkLatency = totalLatency / successfulTests;
                log(`Network Latency: ${networkLatency.toFixed(2)} ms (avg of ${successfulTests} tests)`);
            } else {
                log('All network tests failed');
            }

            try {
                const start = performance.now();
                const response = await fetch('https://httpbin.org/bytes/1048576');
                const data = await response.arrayBuffer();
                const end = performance.now();

                const duration = (end - start) / 1000;
                const bytes = data.byteLength;
                networkBandwidth = (bytes / (1024 * 1024)) / duration;

                log(`Network Bandwidth: ${networkBandwidth.toFixed(2)} MB/s`);
            } catch (e) {
                log(`Bandwidth test failed: ${e.message}`);
            }
        } catch (error) {
            log(`Network test error: ${error.message}`);
        }
    }

    function runQuickProfile() {
        log('Running quick system profile...');
        try {
            const results = profiler.profileSystem();

            log(`<strong>Quick Profile Results:</strong>`);
            log(`CPU Score: ${results.cpuScore.toFixed(2)} MOPS`);
            log(`Memory Bandwidth: ${results.memoryBandwidthMbps.toFixed(2)} MB/s`);
            log(`Recommendation: ${results.recommendation}`);
            log(`Confidence Score: ${(results.confidenceScore * 100).toFixed(1)}%`);
        } catch (error) {
            log(`Error during profiling: ${error.message}`);
        }
    }

    function runStressTest() {
        log('Running stress test (5 seconds)...');
        try {
            const results = profiler.stressTest(5);

            log(`<strong>Stress Test Results:</strong>`);
            log(`Average CPU Score: ${results.avgCpuScore.toFixed(2)} MOPS`);
            log(`Average Memory Bandwidth: ${results.avgMemoryBandwidth.toFixed(2)} MB/s`);
            log(`Iterations Completed: ${results.iterations}`);
            log(`Test Duration: ${results.duration} seconds`);
        } catch (error) {
            log(`Error during stress test: ${error.message}`);
        }
    }

    function getBatteryStatus() {
        log(`<strong>Current Battery Status:</strong>`);
        log(`Battery Level: ${(batteryLevel * 100).toFixed(1)}%`);
        log(`Charging Status: ${isCharging ? 'Charging' : 'Not Charging'}`);
    }

    function runFullProfile() {
        log('Running comprehensive system profile...');

        runNetworkTest().then(() => {
            try {
                const results = profiler.profileSystem();
                const fullResults = {
                    cpuScore: results.cpuScore,
                    memoryBandwidthMbps: results.memoryBandwidthMbps,
                    networkLatencyMs: networkLatency,
                    networkBandwidthMbps: networkBandwidth,
                    batteryLevel: batteryLevel,
                    isCharging: isCharging
                };

                const recommendation = calculateRecommendation(fullResults);

                log(`<strong>Comprehensive Profile Results:</strong>`);
                log(`CPU Score: ${fullResults.cpuScore.toFixed(2)} MOPS`);
                log(`Memory Bandwidth: ${fullResults.memoryBandwidthMbps.toFixed(2)} MB/s`);
                log(`Network Latency: ${fullResults.networkLatencyMs.toFixed(2)} ms`);
                log(`Network Bandwidth: ${fullResults.networkBandwidthMbps.toFixed(2)} MB/s`);
                log(`Battery Level: ${(fullResults.batteryLevel * 100).toFixed(1)}%`);
                log(`Charging: ${fullResults.isCharging ? 'Yes' : 'No'}`);
                log(`<strong>Recommendation: ${recommendation.decision}</strong>`);
                log(`Confidence: ${(recommendation.confidence * 100).toFixed(1)}%`);
            } catch (error) {
                log(`Error during full profile: ${error.message}`);
            }
        });
    }

    document.addEventListener('visibilitychange', function () {
        if (document.hidden) {
            log('Page hidden - profiling paused');
        } else {
            log('Page visible - profiling resumed');
        }
    });

    // Entry point
    Module().then((instance) => {
        profiler = new instance.SystemProfiler();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('controls').style.display = 'block';
        log('WASM module loaded successfully!');
        initializeBatteryAPI();

        // Attach to global for button onclick
        window.runQuickProfile = runQuickProfile;
        window.runStressTest = runStressTest;
        window.runNetworkTest = runNetworkTest;
        window.getBatteryStatus = getBatteryStatus;
        window.runFullProfile = runFullProfile;
    });
</script>
</body>
</html>
